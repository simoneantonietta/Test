/*
 * PROJECT:  WUtilities
 *
 * FILENAME: Serializer.cpp
 *
 * PURPOSE:
 *
 *
 * LICENSE: please refer to LICENSE.TXT
 * CREATED: 11-giu-2009
 * AUTHOR:  Luca Mini
 */

#include "Serializer.h"


/**
 * function to initialize for save data
 * @param appName name of the application
 * @param name title of the file (type of the file)
 * @param appVersion version of the application
 */
void Serializer::initSave(string appName,string appVersion,string fileVersion,string name)
{
initBuffer();
setupBufferHeader(appName,appVersion,fileVersion,name);
};

/**
 * function to initialize data for load data
 */
void Serializer::initLoad()
{
initBuffer();
initBlock();
}

/**
 * function to conclude save/load operations
 */
void Serializer::closeOperation()
{
if(buffer!=NULL)
	delete buffer;
buffer=NULL;
if(block!=NULL)
	delete block;
block=NULL;
}

/**
 * initialize the file buffer to collect all blocks
 */
void Serializer::initBuffer()
{
if(buffer==NULL)
	buffer=new qserializer_t;
else if(!buffer->empty())
	{
	delete buffer;
	buffer=new qserializer_t;
	}
blockCount=0;
}
/**
 * setup the header of the buffer for its use for save a file
 * @param appName name of the application
 * @param name title of the file (type of the file)
 * @param appVersion version of the application
 */
void Serializer::setupBufferHeader(string appName,string appVersion,string fileVersion,string name)
{
char hdr[200];
sprintf(hdr,"<%s:APPNAME %s:APPVER %s:FILEVER %s:LIBVER %s:FILE %s>",hdrName.c_str(),appName.c_str(),appVersion.c_str(),fileVersion.c_str(),SERIALIZER_VERSION,name.c_str());
for(unsigned int i=0;i<strlen(hdr);i++)
	buffer->push(hdr[i]);
}

/**
 * finalize the file buffer: add the end tag.
 * NOTE: it doesn't free buffer memory, becouse it must
 * be saved in a file!
 */
void Serializer::finalizeBuffer()
{
char hdr[50];

sprintf(hdr,"<EOF:%u>",blockCount);
for(unsigned int i=0;i<strlen(hdr);i++)
	buffer->push(hdr[i]);
}

/**
 * initialize a block of data
 * this is overloaded for "write" direction.
 * For read this function is effectiuvely unnecessary because block
 * is automatically generated by getNextBlock
 */
void Serializer::initBlock()
{
// prepare block if need
if(block==NULL)
	block=new qserializer_t;
else if(!block->empty())
	{
	delete block;
	block=new qserializer_t;
	}
}

/**
 * initialize a block of data
 * @param blockName name for the block
 * @param nelem number of elements (i.e. vectors)
 * @param size size of each element. If =0 means to ignore this field
 * @param type specifies the type of the data stored
 */
void Serializer::initBlock(string blockName,unsigned int nelem, size_t size,int type)
{
block=new qserializer_t;
char hdr[100];

blockInfo.name=blockName;
blockInfo.nelem=nelem;
blockInfo.size=size;
blockInfo.type=type;

sprintf(hdr,"<B:%s:%u:%u:%d>",blockName.c_str(),nelem,(unsigned int)size,type);
for(unsigned int i=0;i<strlen(hdr);i++)
	block->push(hdr[i]);
}

/**
 * finalize a block of data: it close with end tag, copy
 * block data to buffer and free memory
 */
void Serializer::finalizeBlock()
{
char hdr[10];
sprintf(hdr,"<E>");

for(unsigned int i=0;i<strlen(hdr);i++)
	block->push(hdr[i]);

if(buffer!=NULL)	// if buffer is defined
	{
	appendToQueue(*block,*buffer);	// join the block to the file buffer
	blockCount++;
	delete block;
	block=NULL;
	}
}

/**
 * add block to buffer
 */
void Serializer::appendBlock2Buffer()
{
if(buffer!=NULL) appendToQueue(*block, *buffer);
}

/**
 * append a vector of char to another vector of char
 * @param to_append		vector to append
 * @param dest				vector destination
 */
void Serializer::appendToQueue(qserializer_t &to_append,qserializer_t &dest)
{
while(!to_append.empty())
	{
	dest.push(to_append.front());
	to_append.pop();
	}
}

/**
 * Save data buffer to a file. This routine empty the buffer.
 * @param filename filename with path where to save data
 * @return true:ok; false:error
 */
bool Serializer::saveFile(string filename)
{
ofstream os;
bool ret;

os.open(filename.c_str(),ios::binary);
if(os.good())
	{
	while(!buffer->empty())
		{
		os << buffer->front();
		buffer->pop();
		}
	ret=true;
	}
else
	ret=false;
os.close();
return(ret);
}

/**
 * load data buffer to a file. This routine empty the buffer.
 * @param filename filename with path where to save data
 * @return true:ok; false:error
 */
bool Serializer::loadFile(string filename)
{
ifstream is;
bool ret=true;
char c;
unsigned int cnt=0;
string header;
vector<string> flds;
char *buff=new char[hdrName.size()+3];
int st=0;
bool hdrFound=false;

initBuffer();

is.open(filename.c_str(),ios::binary);
is>>noskipws;

// get number of blocks
string nBlocks;
is.seekg(0, ios::end);
int pos = is.tellg();
pos--;
if(is.good())
	{
	do
		{
		is.seekg(pos);
		is >> c;
		if(isdigit(c)) nBlocks.append(1,c);
		pos--;
		} while(is.good() && c!=':');
	reverse(nBlocks.begin(),nBlocks.end());	// reverse the string
	}

// get all data
is.seekg (0, ios::beg);	// reset file pointer
while(is.good())
	{
	is >> c;
	buff[st]=c;
	cnt++;	// bytes counter

	// preliminary check
	if(cnt<=(hdrName.size()+1))
		{
		if(buff[st]==hdrName[st])
			{
			st++;
			if((unsigned int)st==hdrName.size())
				{
				hdrFound=true;
				st=0;
				}
			}
		}
	buffer->push(c);
	}
delete [] buff;

// elab. of the data
if(hdrFound)
	{
	// get info from header
	do
		{
		if(!buffer->empty())
			{
			c=buffer->front();
			header.append(1,buffer->front());
			buffer->pop();
			}
		} while(c!='>');

	Split(header,flds,"<: >");
	// <%s:APPNAME %s:APPVER %s:FILEVER %s:LIB %s:FILE %s>
	if(flds.size()==11)
		{
		bufferInfo.appName=flds[2];
		bufferInfo.appVersion=flds[4];
		bufferInfo.fileVersion=flds[6];
		bufferInfo.serializerVersion=flds[8];
		bufferInfo.name=flds[10];
		bufferInfo.nBytes=cnt;
		bufferInfo.blockCount=to_number<unsigned int>(nBlocks);
		}
	else
		{
		ret=false;
		bufferInfo.name="ERROR in hdr";
		bufferInfo.nBytes=0;
		}
	}
else
	{
	ret=false;
	bufferInfo.name="ERROR invalid file";
	bufferInfo.nBytes=0;
	}
is.close();
return(ret);
}

/**
 * move next block from buffer to block buffer
 */
bool Serializer::getNextBlock()
{
int st=0;
char end[]="<E>";
char buff[5];
bool end_f=false,move;
bool ret=true;

// prepare block if need
initBlock();

// elaboration
do
	{
	if(!buffer->empty())
		{
		buff[st]=buffer->front();
		buffer->pop();
		move=true;

		// check for END
		if(buff[st]==end[st])
			{
			st++;
			if((unsigned int)st==strlen(end)) end_f=true;
			move=false;
			}
		else
			{
			move=true;
			}
		// moving data
		if(move && !end_f)
			{
			for(int i=0;i<=st;i++)
				{
				block->push(buff[i]);
				}
			st=0;
			}
		}
	else
		ret=false;
	} while(!end_f);
return(ret);
}

/**
 * get info of the next block from its header
 * it expect a block in block buffer
 */
bool Serializer::getBlockInfo()
{
bool ret=false;
string header;
vector<string> flds;
char c;

if(block==NULL) return(false);

// get info from the block header
do
	{
	if(!block->empty())
		{
		c=block->front();
		header.append(1,block->front());
		block->pop();
		}
	} while(c!='>' && !block->empty());

// <B:%s:%u:%u:%d>
Split(header,flds,"<:>");
if(flds.size()==5)
	{
	blockInfo.name=flds[1];
	blockInfo.nelem=to_number<unsigned int>(flds[2]);
	blockInfo.size=to_number<unsigned int>(flds[3]);
	blockInfo.type=to_number<unsigned int>(flds[4]);
	}
else
	{
	ret=false;
	blockInfo.name="ERROR";
	}
return(ret);
}
