/*
 *-----------------------------------------------------------------------------
 * PROJECT: gpsnif
 * PURPOSE: see module GuiMainWindow.h file
 *-----------------------------------------------------------------------------
 */

#include <iostream>
#include <string>
#include <fstream>
#include <iomanip>
#include <algorithm>

#include "GuiMainWindow.h"
#include "GuiPlacer.h"
#include "ScopeViewWindow.h"
#include "common/utils/Utils.h"
#include "common/utils/Trace.h"
#include "common/utils/SimpleCfgFile.h"
#include "comm/SerCommTh.h"
#include "comm/FifoCommTh.h"
#include "comm/SktCliCommTh.h"
#include "comm/SktSrvCommTh.h"
#include "comm/UDPCommTh.h"
#include "RXHFrame.h"
#include "TXHFrame.h"
#include "WrapPicoc.h"
#include "gpsnif.xpm"	// icon

extern struct globals_st gd;
extern Trace *dbg;
extern SerCommTh *serComm;
extern SktCliCommTh *sktCliComm;
extern SktSrvCommTh *sktSrvComm;
extern UDPCommTh *udpSrvComm;
extern FifoCommTh *fifoComm;
extern RXHFrame *rf;
extern TXHFrame *tf;
extern SimpleCfgFile *cfg;
extern WrapPicoc *wp;

// scope vars
extern ScopeViewWindow *scope;

extern void endingApplication();

extern "C"
{
void simplePrintMessage(const char *m);
}

Fl_Text_Display::Style_Table_Entry stable[] =
		{
			// FONT COLOR      	FONT FACE   FONT SIZE
			// --------------- 	----------- --------------
			{  FL_BLACK,				FL_COURIER,	12 }, // A - black
			{  FL_GRAY,					FL_COURIER,	12 }, // B - gray
			{  FL_RED,					FL_COURIER,	12 }, // C - Red
			{  FL_DARK_YELLOW,	FL_COURIER,	12 }, // D - Yellow
			{  FL_DARK_GREEN,		FL_COURIER,	12 }, // E - Green
			{  FL_BLUE,					FL_COURIER,	12 }, // F - Blue
			{  FL_DARK_CYAN,		FL_COURIER,	12 }, // G - Cyan
			{  FL_DARK_BLUE,		FL_COURIER,	12 }, // H - Blue
			{  FL_DARK3,				FL_COURIER,	12 }, // I - light gray
			{  FL_DARK_RED,			FL_COURIER,	12 }, // J - light gray
			{  FL_DARK_MAGENTA,	FL_COURIER,	12 }, // K - dark magenta
		};


using namespace std;

/**
 * ctor
 */
GuiMainWindow::GuiMainWindow()
{
needRefresh=false;
enableLog=false;
markerNumber=0;
}

/**
 * dtor
 */
GuiMainWindow::~GuiMainWindow()
{
}

/**
 * callback to handle main windows callback
 * @param
 * @param
 */
static void onMainWindow_CB(Fl_Widget*, void*)
{
if (Fl::event()==FL_SHORTCUT && Fl::event_key()==FL_Escape)
    return; // ignore Escape

if(fl_choice("Do you want to quit?", "No", "Yes", NULL))
	{
	if(gd.connected)
		{
		switch(gd.interface)
			{
			case globals_st::if_serial:
				serComm->closeCommunication();
				break;
			case globals_st::if_socket_cli:
				sktCliComm->closeCommunication();
				break;
			case globals_st::if_socket_srv:
				sktSrvComm->closeCommunication();
				break;
			case globals_st::if_socket_udp:
				udpSrvComm->closeCommunication();
				break;
			case globals_st::if_fifo:
				sktCliComm->closeCommunication();
				break;
			}
		}
	endingApplication();
	exit(0);
	}
}

/**
 * render the window
 * NOTE: arguments are not used here
 *
 */

void GuiMainWindow::render(int argc,char **argv)
{
GuiPlacer gp;

if(gd.reducedSize)
	win=new Fl_Double_Window(GUI_MAINWIN_SIZEW,GUI_MAINWIN_SIZEH-GUI_REDUCED_FACTOR,GUI_TITLE);
else
	win=new Fl_Double_Window(GUI_MAINWIN_SIZEW,GUI_MAINWIN_SIZEH,GUI_TITLE);
win->callback(onMainWindow_CB);

win->xclass(APP_NAME);
win->iconlabel(APP_NAME);
Fl_Pixmap *icon_pix=new Fl_Pixmap(gpsnif_xpm);
Fl_RGB_Image *icon_img=new Fl_RGB_Image(icon_pix, Fl_Color(0));
win->icon(icon_img);


win->begin();
	{
	fl_message_title_default(APP_NAME);

	// log
	if(gd.reducedSize)
		gp.placeOffset(win,GUI_LEFT_BORDER,GUI_TOP_BORDER,GUI_LOG_SIZEW,GUI_LOG_SIZEH-GUI_REDUCED_FACTOR);
	else
		gp.placeOffset(win,GUI_LEFT_BORDER,GUI_TOP_BORDER,GUI_LOG_SIZEW,GUI_LOG_SIZEH);
	log_txt=new Fl_Text_Display(GUIPLC_GETPOS(gp), "Log");
	log_txt->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	log_tbuff= new Fl_Text_Buffer(16*1024);
	log_sbuff= new Fl_Text_Buffer(16*1024);
	log_txt->buffer(log_tbuff);
	stable_size = sizeof(stable)/sizeof(stable[0]);
	log_txt->highlight_data(log_sbuff, stable, stable_size, 'A', 0, 0);
	//log_txt->color(FL_BLACK);
//	log_tbuff->text("gpsnif log begin\n");
//	log_sbuff->text("AAAAAAAAAAAAAAAA\n");

	// perc log fill indicator
	gp.placeOffset(log_txt,50,-(GUI_PERCCLEAR_SIZEH),GUI_PERCCLEAR_SIZEW,GUI_PERCCLEAR_SIZEH);
	percClear=new Fl_Box(GUIPLC_GETPOS(gp), "0%");
	percClear->tooltip("log buffer screen fill, approaching to 100% it will be near to auto-clearing");
	percClear->color((Fl_Color)FL_GREEN);
	percClear->box(FL_ROUND_DOWN_BOX);

	// load and parse a file
	gp.placeRight(percClear,GUI_FILE_SIZEW,GUI_FILE_SIZEH);
	file_but=new Fl_Button(GUIPLC_GETPOS(gp), "File");
	file_but->tooltip("load and parse a binary file containing protocol data frames");
	file_but->callback(STATIC_CALLBACK_NAME(onFile_CB),this);

	// refresh maps reloading all
	gp.placeRight(file_but,GUI_RELOAD_MAP_SIZEW,GUI_RELOAD_MAP_SIZEH,20);
	reload_but=new Fl_Button(GUIPLC_GETPOS(gp), "Rld");
	reload_but->tooltip("Reload map files");
	reload_but->callback(STATIC_CALLBACK_NAME(onReload_CB),this);

	// list of data devices
	gp.placeRight(reload_but,GUI_FRAMEANAL_SIZEW,GUI_FRAMEANAL_SIZEH,20);
	frameAnalyzer_but=new Fl_Button(GUIPLC_GETPOS(gp), "FrmA");
	frameAnalyzer_but->tooltip("Dialog for frame analysis");
	frameAnalyzer_but->callback(STATIC_CALLBACK_NAME(onFrameAnalizer_CB),this);

	// start dialog for frame analizer
	gp.placeRight(frameAnalyzer_but,GUI_LISTDEV_MAP_SIZEW,GUI_LISTDEV_MAP_SIZEH,20);
	listDevices_but=new Fl_Button(GUIPLC_GETPOS(gp), "Stat");
	listDevices_but->tooltip("list of devices and some statistics");
	listDevices_but->callback(STATIC_CALLBACK_NAME(onListDevices_CB),this);

	// pause button
	gp.placeBelow(log_txt,GUI_LOG_BUTTONS_SIZEW,GUI_LOG_BUTTONS_SIZEH,5);
	pause_but=new Fl_Light_Button(GUIPLC_GETPOS(gp), "Pause");
	pause_but->callback(STATIC_CALLBACK_NAME(onPause_CB),this);

	// clear button
	gp.placeRight(pause_but,GUI_LOG_BUTTONS_SIZEW,GUI_LOG_BUTTONS_SIZEH,20);
	clear_but=new Fl_Button(GUIPLC_GETPOS(gp), "Clear");
	clear_but->callback(STATIC_CALLBACK_NAME(onClear_CB),this);

	// mark button
	gp.placeBelow(clear_but,GUI_LOG_BUTTONS_SIZEW,GUI_LOG_BUTTONS_SIZEH,3);
	mark_but=new Fl_Button(GUIPLC_GETPOS(gp), "Mark");
	mark_but->callback(STATIC_CALLBACK_NAME(onMark_CB),this);
	mark_but->tooltip("place a textual marker");

	// timer start
	gp.placeRight(mark_but,GUI_TIMER_START_SIZEW,GUI_TIMER_START_SIZEH,20);
	timerStart=new Fl_Input(GUIPLC_GETPOS(gp), "@-1->");
	timerStart->tooltip("filter to start the timer");

	// timer stop
	gp.placeRight(timerStart,GUI_TIMER_STOP_SIZEW,GUI_TIMER_STOP_SIZEH,20);
	timerStop=new Fl_Input(GUIPLC_GETPOS(gp), "@-5square");
	timerStop->tooltip("filter to stop the timer");

	// timer
	gp.placeRight(timerStop,GUI_TIMER_SIZEW,GUI_TIMER_SIZEH,5);
	timerWatch=new Fl_Box(GUIPLC_GETPOS(gp), "00:00:00 000");
	timerWatch->color((Fl_Color)FL_CYAN);
	timerWatch->box(FL_ROUND_DOWN_BOX);

	// timer enable button
	gp.placeRight(timerWatch,GUI_TIMER_STOP_SIZEW,GUI_TIMER_STOP_SIZEH,5);
	timerEnable=new Fl_Light_Button(GUIPLC_GETPOS(gp), "@|>");
	timerEnable->callback(STATIC_CALLBACK_NAME(onMark_CB),this);
	timerEnable->tooltip("start timer; if filters are both empty, it start and stop");
	timerEnable->callback(STATIC_CALLBACK_NAME(onTimerEnable_CB),this);

	// communication device
	gp.placeRight(log_txt,GUI_COMMDEV_SIZEW,GUI_COMMDEV_SIZEH,3);
	commDevice_in=new Fl_Input(GUIPLC_GETPOS(gp), "Device");
	commDevice_in->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	if(strlen(gd.device))
		{
		commDevice_in->value(gd.device);
		}
	commDevice_in->tooltip("can be:\n"
			"- serial device (/dev/ttyUSB0)\n"
			"- fifo, if start with ':' (:/tmp/fifo.bin)\n"
			"- socket client IP server (192.168.1.10 or localhost)\n"
			"- server (write: 'server' in the field\n"
			"- udp (write: 'udp' in the field");

	// baud rate
	gp.placeRight(commDevice_in,GUI_COMMBRATE_SIZEW,GUI_COMMBRATE_SIZEH,10);
	commBR_in=new Fl_Input(GUIPLC_GETPOS(gp), "BaudRate/Port");
	commBR_in->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	if(checkDeviceType(gd.device)==DEV_TYPE_SOCKET)
		{
		if(gd.port!=0)
			{
			char _tmp[10];
			itoa_buf(_tmp,10,gd.port);
			commBR_in->value(_tmp);
			}
		}
	else
		{
		if(gd.brate!=0)
			{
			char _tmp[10];
			itoa_buf(_tmp,10,gd.brate);
			commBR_in->value(_tmp);
			}
		}

	// connect button
	gp.placeRight(commBR_in,GUI_CONNECT_SIZEW,GUI_CONNECT_SIZEH,10);
	connect_but=new Fl_Button(GUIPLC_GETPOS(gp), "Connect");
	connect_but->callback(STATIC_CALLBACK_NAME(onConnect_CB),this);

	// crypto key
	gp.placeBelow(commDevice_in,GUI_CRYPTO_KEY_SIZEW,GUI_CRYPTO_KEY_SIZEH,20);
	cryptoKey_in=new Fl_Input(GUIPLC_GETPOS(gp), "Crypto key");
	cryptoKey_in->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	cryptoKey_in->tooltip("enter the new crypto key (four hex bytes)\ni.e.: 4e7f33d9");
	cryptoKey_in->maximum_size(HPROT_CRYPT_KEY_SIZE*2);
	char _keytmp[100];
	Hex2AsciiHex(_keytmp,gd.hprotKey,HPROT_CRYPT_KEY_SIZE,false,0);
	cryptoKey_in->value(_keytmp);

	// crypto set
	gp.placeRight(cryptoKey_in,GUI_CRYPTO_SET_SIZEW,GUI_CRYPTO_SET_SIZEH,10);
	setCryptoKey_but=new Fl_Button(GUIPLC_GETPOS(gp), "Set");
	setCryptoKey_but->callback(STATIC_CALLBACK_NAME(onCryptoKeySet_CB),this);
	setCryptoKey_but->tooltip("set the new key");

	// crypto enable
	gp.placeRight(setCryptoKey_but,GUI_CRYPTO_EN_SIZEW,GUI_CRYPTO_EN_SIZEH,10);
	enCrypto_ck=new Fl_Check_Button(GUIPLC_GETPOS(gp), "enable crypto");
	enCrypto_ck->callback(STATIC_CALLBACK_NAME(onEnableCrypto_CB),this);
	enCrypto_ck->tooltip("enable/disable crypto algorithm");
	if(gd.enableCrypto)
		{
		enCrypto_ck->value(1);
		}
	else
		{
		enCrypto_ck->value(0);
		}

	// my id
	gp.placeBelow(cryptoKey_in,GUI_ID_SIZEW,GUI_ID_SIZEH,20);
	myId_in=new Fl_Int_Input(GUIPLC_GETPOS(gp), "src ID");
	myId_in->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	if(gd.myID!=0)
		{
		char _tmp[10];
		itoa_buf(_tmp,10,gd.myID);
		myId_in->value(_tmp);
		}

	// dst id
	gp.placeRight(myId_in,GUI_ID_SIZEW,GUI_ID_SIZEH,30);
	destId_in=new Fl_Int_Input(GUIPLC_GETPOS(gp), "dst ID");
	destId_in->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	if(gd.defaultDest!=0)
		{
		char _tmp[10];
		itoa_buf(_tmp,10,gd.defaultDest);
		destId_in->value(_tmp);
		}

	// check link button
	gp.placeRight(destId_in,GUI_CKLNK_SIZEW,GUI_CKLNK_SIZEH,30);
	cklnk_but=new Fl_Button(GUIPLC_GETPOS(gp), "Check");
	cklnk_but->callback(STATIC_CALLBACK_NAME(onCkLnk_CB),this);
	cklnk_but->tooltip("check the communications with the destination ID");

	// result
	gp.placeRight(cklnk_but,GUI_RESULT_SIZEW,GUI_RESULT_SIZEH,50);
	result_box=new Fl_Box(GUIPLC_GETPOS(gp), "----");
	result_box->color((Fl_Color)FL_CYAN);
	result_box->box(FL_ROUND_UP_BOX);
	result_box->tooltip("answer or info from the protocol");

	// commands
	gp.placeBelow(myId_in,GUI_COMMANDS_SIZEW,GUI_COMMANDS_SIZEH,20);
	cmds_cb = new Fl_Input_Choice(GUIPLC_GETPOS(gp), "Command [typ.src.dst.cmd.data]");
	cmds_cb->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	cmds_cb->tooltip(	"Format: typ.src.dst.cmd.data\n"
										"where\n"
										"typ: type of frame [c|r|a]\n"
										"src: source ID, start with x for hex [0..255]; if 's' take it from the GUI"
										"dst: destination ID, start with x for hex [0..255]; if 'd' take it from the GUI\n"
										"cmd: command, start with x for hex [0..255]\n"
										"data: x[...]i[...]s[string]; you MUST use [] to fill data\n"
										"use '.' to separate each value that must be of one byte\n"
										"i.e.:\n"
										"r.1.x12.x21.x[12.fd].i[123]\n"
										"r.s.d.3\n"
										);
	if(!fillCommands())
		{
		return;
		}

	// send button
	gp.placeRight(cmds_cb,GUI_SEND_SIZEW,GUI_SEND_SIZEH,5);
	send_but=new Fl_Button(GUIPLC_GETPOS(gp), "Send");
	send_but->callback(STATIC_CALLBACK_NAME(onSend_CB),this);
	send_but->tooltip("send the command");

	// filter
	gp.placeBelow(cmds_cb,GUI_FILTER_SIZEW,GUI_FILTER_SIZEH,40);
	filter_cb=new Fl_Input_Choice(GUIPLC_GETPOS(gp), "Message filter");
	filter_cb->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	filter_cb->tooltip(	"set filter\n"
											"each field is separated by .\neach values are decimal\n"
											"h[cra] filters the header\n"
											"s[num] filters the source and 'num' can be a range [min-max]\n"
											"d[num] filters the destination and 'num' can be a range [min-max]\n"
											"c[num] filters the command and 'num' can be a range [min-max]\n"
											"a '!' at the beginning of a filter means invert the result\n"
											"\n"
											"multiple filters can be combinated (max 10) by operator '*' (and) and '+' (or)\n"
											"for example:\n"
											"ha.s2.d[2-3]+d5.c3\n"
											"print frame answer from source 2 and destination from 2 to 3 and 5, with command 3"
										);
	if(!fillFilters())
		{
		return;
		}
	// filter set
	gp.placeRight(filter_cb,GUI_FILTERSET_SIZEW,GUI_FILTERSET_SIZEH,5);
	filterSet_but=new Fl_Button(GUIPLC_GETPOS(gp), "Set");
	filterSet_but->callback(STATIC_CALLBACK_NAME(onFilterSet_CB),this);
	filterSet_but->tooltip("press this to validate and load the filter specified");

	// enable debug filters
	gp.placeBelow(filter_cb,GUI_DBGFILTER_SIZEW,GUI_DBGFILTER_SIZEH,5);
	enDbgFilter_ck=new Fl_Check_Button(GUIPLC_GETPOS(gp), "only debug msg");
	enDbgFilter_ck->callback(STATIC_CALLBACK_NAME(onEnableDbgFilter_CB),this);
	enDbgFilter_ck->tooltip("enable/disable the filter for debug messages only");

	// show mapped commands
	gp.placeRight(enDbgFilter_ck,GUI_MAPCMD_SIZEW,GUI_MAPCMD_SIZEH,10);
	enMapCommands_ck=new Fl_Check_Button(GUIPLC_GETPOS(gp), "mapped cmd");
	enMapCommands_ck->callback(STATIC_CALLBACK_NAME(onEnableMappedCommands_CB),this);
	enMapCommands_ck->tooltip("enable/disable showing mapped commands");
	enMapCommands_ck->value(1);

	// enable filters
	gp.placeRight(enMapCommands_ck,GUI_ENFILTER_SIZEW,GUI_ENFILTER_SIZEH,10);
	enFilter_ck=new Fl_Check_Button(GUIPLC_GETPOS(gp), "filter enable");
	enFilter_ck->callback(STATIC_CALLBACK_NAME(onEnableFilter_CB),this);
	enFilter_ck->tooltip("enable/disable the filter");

	// variable browser
	gp.placeBelow(filter_cb,GUI_VARBROWSER_SIZEW,log_txt->y()+log_txt->h()-(filter_cb->y()+GUI_ENFILTER_SIZEH +50),50);
	varBrowser_br=new Fl_Browser(GUIPLC_GETPOS(gp), "Variables");
	varBrowser_br->align(Fl_Align(FL_ALIGN_TOP_LEFT));
	varBrowser_br->type(FL_MULTI_BROWSER);
	int colWidths[]={GUI_VARNAME_WIDTH,GUI_VARBROWSER_SIZEW-GUI_VARNAME_WIDTH};
	varBrowser_br->column_widths(colWidths);
	varBrowser_br->column_char('\t');
	varBrowser_br->tooltip("shows variables sent at the debug ID in the right format");

	// spare buttons------------------------------------------------------
	gp.placeRight(varBrowser_br,GUI_SPARE_BUT_SIZEW,GUI_SPARE_BUT_SIZEH,20);
	spare_but[0]=new Fl_Button(GUIPLC_GETPOS(gp));
	spare_but[0]->copy_label((to_string(1) + "_" + gd.spareButton[0].name).c_str());
	//spare0_but->color(FL_YELLOW);
	spare_but[0]->tooltip(gd.spareButton[0].tooltip.c_str());
	spare_but[0]->callback(STATIC_CALLBACK_NAME(onSpareButton_CB),this);
	(gd.spareButton[0].enable) ? (spare_but[0]->activate()) : (spare_but[0]->deactivate());

	for(int k=1;k<SPARE_BUTTONS_N;k++)
		{
		int vspace=20;
		if(gd.reducedSize) vspace=10;
		gp.placeBelow(spare_but[k-1],GUI_SPARE_BUT_SIZEW,GUI_SPARE_BUT_SIZEH,vspace);
		spare_but[k]=new Fl_Button(GUIPLC_GETPOS(gp));
		spare_but[k]->copy_label((to_string(k+1) + "_" + gd.spareButton[k].name).c_str());
		//spare1_but->color(FL_YELLOW);
		spare_but[k]->tooltip(gd.spareButton[k].tooltip.c_str());
		spare_but[k]->callback(STATIC_CALLBACK_NAME(onSpareButton_CB),this);
		(gd.spareButton[k].enable) ? (spare_but[k]->activate()) : (spare_but[k]->deactivate());
		}
	// spare buttons------------------------------------------------------

	// clear variable
	gp.placeBelow(varBrowser_br,GUI_VARCLEAR_SIZEW,GUI_VARCLEAR_SIZEH,5);
	varClear_but=new Fl_Button(GUIPLC_GETPOS(gp), "Clear");
	varClear_but->callback(STATIC_CALLBACK_NAME(onVarClear_CB),this);

	// plot variable
	gp.placeRight(varClear_but,GUI_VARPLOT_SIZEW,GUI_VARPLOT_SIZEH,30);
	varPlot_but=new Fl_Button(GUIPLC_GETPOS(gp), "Plot");
	varPlot_but->callback(STATIC_CALLBACK_NAME(onVarPlot_CB),this);
	varPlot_but->tooltip("plot variables (with gnuplot");
	//varPlot_but->hide();

	// frame counters
	if(gd.reducedSize)
		gp.placeOffset(win,GUI_MAINWIN_SIZEW-GUI_FRAMECOUNT_SIZEW,GUI_MAINWIN_SIZEH-GUI_REDUCED_FACTOR-GUI_FRAMECOUNT_SIZEH,GUI_FRAMECOUNT_SIZEW,GUI_FRAMECOUNT_SIZEH);
	else
		gp.placeOffset(win,GUI_MAINWIN_SIZEW-GUI_FRAMECOUNT_SIZEW,GUI_MAINWIN_SIZEH-GUI_FRAMECOUNT_SIZEH,GUI_FRAMECOUNT_SIZEW,GUI_FRAMECOUNT_SIZEH);
	txFrameCount_box=new Fl_Box(GUIPLC_GETPOS(gp), "----");
	txFrameCount_box->labelsize(10);
	//txFrameCount_box->labeltype(FL_SHADOW_LABEL);
	txFrameCount_box->color((Fl_Color)FL_LIGHT1);
	txFrameCount_box->box(FL_FLAT_BOX);
	txFrameCount_box->tooltip("TX frame count");

	gp.placeLeft(txFrameCount_box,GUI_FRAMECOUNT_SIZEW,GUI_FRAMECOUNT_SIZEH,5);
	rxFrameCount_box=new Fl_Box(GUIPLC_GETPOS(gp), "----");
	rxFrameCount_box->labelsize(10);
	//txFrameCount_box->labeltype(FL_SHADOW_LABEL);
	rxFrameCount_box->color((Fl_Color)FL_LIGHT1);
	rxFrameCount_box->box(FL_FLAT_BOX);
	rxFrameCount_box->tooltip("RX frame count");

	// Status
	gp.placeLeft(rxFrameCount_box,GUI_STATUS_SIZEW,GUI_STATUS_SIZEH,5);
	status_box=new Fl_Box(GUIPLC_GETPOS(gp), "----");
	status_box->labelsize(10);
	//txFrameCount_box->labeltype(FL_SHADOW_LABEL);
	status_box->labelcolor(FL_BLACK);
	status_box->color((Fl_Color)FL_LIGHT2);
	status_box->box(FL_FLAT_BOX);
	status_box->tooltip("gpsnif status");

	// clear counters
	gp.placeLeft(status_box,GUI_CLEARCOUNTERS_SIZEW,GUI_CLEARCOUNTERS_SIZEH,3);
	clearCounters_but=new Fl_Button(GUIPLC_GETPOS(gp), "C");
	clearCounters_but->color(FL_YELLOW);
	clearCounters_but->tooltip("clear all counters");
	clearCounters_but->callback(STATIC_CALLBACK_NAME(onClearCounters_CB),this);

	// logs raw bin
	gp.placeRight(clear_but,GUI_LOGENABLE_SIZEW,GUI_LOGENABLE_SIZEH,30);
	logRawBin_ck=new Fl_Check_Button(GUIPLC_GETPOS(gp), "log raw bin");
	logRawBin_ck->callback(STATIC_CALLBACK_NAME(onLogRawBin_CB),this);
	logRawBin_ck->tooltip("generate binary file as received from the comm port");
	//logRawBin_ck->shortcut(FL_CTRL + 'z');

	gp.placeRight(logRawBin_ck,GUI_LOGENABLE_SIZEW,GUI_LOGENABLE_SIZEH,5);
	logRawTxt_ck=new Fl_Check_Button(GUIPLC_GETPOS(gp), "log raw txt");
	logRawTxt_ck->callback(STATIC_CALLBACK_NAME(onLogRawTxt_CB),this);
	logRawTxt_ck->tooltip("generate text file of frames in hex");
	//logRawTxt_ck->shortcut(FL_CTRL + 'x');

	gp.placeRight(logRawTxt_ck,GUI_LOGENABLE_SIZEW,GUI_LOGENABLE_SIZEH,5);
	logParsTxt_ck=new Fl_Check_Button(GUIPLC_GETPOS(gp), "log parsed");
	logParsTxt_ck->callback(STATIC_CALLBACK_NAME(onLogParsTxt_CB),this);
	logParsTxt_ck->tooltip("generate text file of the parsed frames");
	//logParsTxt_ck->shortcut(FL_CTRL + 'c');

	// delete logs
	gp.placeRight(logParsTxt_ck,GUI_DELETELOGS_SIZEW,GUI_DELETELOGS_SIZEH,5);
	deleteLogFiles_but=new Fl_Button(GUIPLC_GETPOS(gp), "X");
	deleteLogFiles_but->color(FL_YELLOW);
	deleteLogFiles_but->tooltip("delete all log files");
	deleteLogFiles_but->callback(STATIC_CALLBACK_NAME(onDeleteLogFiles_CB),this);

	}
win->end();
//win->show();
win->show(argc,argv);

//wp->scriptSetup(0,"./scripts/sample0.c","s10",true);
////HDR|SRC|DST|NUM|CMD|LEN|data|CRC8
//uint8_t b[]={0x41,0x10,0x02,0x00,0x03,0x02,0x55,0xAA,0x00};
//wp->execute(0,b,sizeof(b),true);

//showVariables("%%vvar1=3;var2=4.5;var3=33.556");
//showVariables("%%vvargddgd1=3.5;var4=1244.3;var5=0.2311");
//hf->parseFilter("har.c1-13.s3");

// this is to process in background the graphics so it not interfere with events
// NOTE: thie causes CPU to 100%
Fl::add_idle(STATIC_SIMPLE_CALLBACK_NAME(onRefreshGui_CB),this);

//#ifndef GUI_DISABLE_CLIENT_CTRL_AUTOUPDATE
Fl::add_timeout(GUI_CHECK_FRAME_QUEUE, STATIC_SIMPLE_CALLBACK_NAME(onTimerPrintQueue_CB),this);
//#endif

}

/**
 * handle the writing to the log window
 * @param str contains the text to be printed in the following format:
 * "STRING$colorSTRING.....$reset"
 * if start with %%x then the string it threated as a particular thing that depends on 'x'
 * if x is:
 * v	print data in the variables browser
 * s	regular C string
 *
 * for example:
 * "this is a $Amessage$- and $Bmessage2$-"
 */
void GuiMainWindow::printLog(const char *str)
{
int row_ndx=0;
char style=TXT_COLOR_DEFAULT[1];	// set the default style

if(str[0]=='%' && str[1]=='%') // if is a particular data to be displayed..
	{
	switch(str[2])
		{
		case 'v':	// prints variables in the browser
			showVariables(str);
			break;
		case 's':	// prints a regular c string
			trow[0]=0;
			srow[0]=0;
			row_ndx=0;
			while(str[row_ndx+3]!=0)
				{
				trow[row_ndx]=str[row_ndx+3];
				srow[row_ndx]=TXT_COLOR_SCRIPT[1];
				row_ndx++;
				}
			trow[row_ndx]='\n';
			srow[row_ndx]='\n';
			log_tbuff->append(trow);
			log_sbuff->append(srow);
			break;
		default:
			break;
		}
	}
else // standard data to show
	{
	trow[0]=0;
	srow[0]=0;

	// calculate the remaining bytes before autoclearing
	char pac[10];
	int perc=(log_tbuff->length()*100)/GMW_BUFFER;
	sprintf(pac,"%d%%",perc);
	(perc<80) ? (percClear->color((Fl_Color)FL_GREEN)) : (percClear->color((Fl_Color)FL_RED));
	percClear->copy_label(pac);

	if(log_tbuff->length()>=(GMW_BUFFER-100))
		{
		log_tbuff->text("");
		log_sbuff->text("");
		dbg->trace(DBG_NOTIFY,"auto-clearing");
		}

	while(*str!=0)
		{
		switch(*str)
			{
			case '$':
				str++;	// take the style
				if(*str-'A' >= stable_size)
					{
					style=TXT_COLOR_DEFAULT[1];
					}
				else
					{
					if(*str=='-')
						{
						style=TXT_COLOR_DEFAULT[1];
						}
					else
						{
						style=*str;
						}
					}
				str++;
				break;
			case '\r':
				str++;	// ignore
				break;
			case '\n':
				trow[row_ndx]='\n';
				srow[row_ndx]='\n';
				row_ndx++;
				str++;
				trow[row_ndx]=0;
				srow[row_ndx]=0;
				log_tbuff->append(trow);
				log_sbuff->append(srow);

				logToFile(trow);
				//cout << strlen(trow) << "," << strlen(trow) << endl;
				row_ndx=0;
				break;
			default:
				trow[row_ndx]=*str;
				srow[row_ndx]=style;
				row_ndx++;
				str++;
				// terminate always
				trow[row_ndx]=0;
				srow[row_ndx]=0;
				break;
			}
		if(row_ndx>=(GMW_BUFFER-1))
			{
			dbg->trace(DBG_ERROR, _S __FUNCTION__ + ": buffer overflow");
			return;
			}
		}
	if(row_ndx)	// flush last if any
		{
		log_tbuff->append(trow);
		log_sbuff->append(srow);

		logToFile(trow);
		//cout << strlen(trow) << "," << strlen(trow) << endl;
		}
	}
log_txt->insert_position(log_txt->buffer()->length());
log_txt->show_insert_position();
//needRefresh=true;
}

/**
 * get the source id value
 * @return ID or -1 for error
 */
int GuiMainWindow::getMyId()
{
uint8_t ret=-1;
if(IsIntNumber(myId_in->value()))
	{
	int num=atoi(myId_in->value());
	if(isInRange(num,0,255,'B'))
		{
		ret=(uint8_t)num;
		}
	}
return ret;
}

/**
 * get the destination id value
 * @return ID or -1 for error
 */
int GuiMainWindow::getDstId()
{
uint8_t ret=-1;
if(IsIntNumber(destId_in->value()))
	{
	int num=atoi(destId_in->value());
	if(isInRange(num,0,255,'B'))
		{
		ret=(uint8_t)num;
		}
	}
return ret;
}

//-----------------------------------------------------------------------------
// PRIVATE
//-----------------------------------------------------------------------------

/**
 * put the variables list to the browser
 * @param str string that describe variables
 * format:
 * %%vvarname=value;varname=value;
 */
void GuiMainWindow::showVariables(const char* str)
{
if(str[2]!='v') return;

vector<string> toks;
string _s;
string s(&str[3]);
Split(s,toks,";=");

// update var database
varBrowser_br->clear();
for(vector<string>::iterator it=toks.begin(); it<toks.end(); it+=2)
	{
	varDB[*it]=*(it+1);
	}
typedef map<string, string>::iterator varDB_it;
for(varDB_it mit = varDB.begin(); mit != varDB.end(); mit++)
	{
	_s = mit->first + "\t" + mit->second;
	varBrowser_br->add(_s.c_str());
	}
}

/**
 * fill the repertoire combobox
 */
bool GuiMainWindow::fillCommands()
{
ifstream f;
string line;
int nline=0;
int nelem=0;
cmds_cb->clear();
if(gd.cmd_fname.length())
	{
	f.open(gd.cmd_fname.c_str());
	if(f.is_open())
		{
		// read the file
		while (!f.eof())
			{
			nline++;
			getline(f, line);
			trim(line);
			if(line[0]=='#') continue;
			if(line.empty()) continue;
			//cmds_cb->add(line.c_str());
			commandList.push_back(line);
			nelem++;
			}
		}
	}
// invert the order and load it in the cbox
reverse(commandList.begin(),commandList.end());
FOR_EACH(it,string,commandList)
	{
	cmds_cb->add(it->c_str());
	}
if(nelem>0) cmds_cb->value(0);	// select the default (first)
return true;
}

/**
 * fill the repertoire combobox
 */
bool GuiMainWindow::fillFilters()
{
ifstream f;
string line;
int nline=0;
int nelem=0;

filter_cb->clear();
if(gd.fil_fname.length())
	{
	f.open(gd.fil_fname.c_str());
	if(f.is_open())
		{
		// read the file
		while (!f.eof())
			{
			nline++;
			getline(f, line);
			trim(line);
			if(line[0]=='#') continue;
			if(line.empty()) continue;
			//filter_cb->add(line.c_str());
			filterList.push_back(line);
			nelem++;
			}
		}
	}
// invert the order and load it in the cbox
reverse(filterList.begin(),filterList.end());
FOR_EACH(it,string,filterList)
	{
	filter_cb->add(it->c_str());
	}
if(nelem>0) filter_cb->value(0);	// select the default (first)
return true;
}

//-----------------------------------------------------------------------------
// UTILTIES
//-----------------------------------------------------------------------------
/**
 * get an integer value from a string
 * @param val
 * @param minValue
 * @param maxValue
 * @param ival value converted
 * @return true: ok
 */
bool GuiMainWindow::getFldNumber(const char *val,int minValue, int maxValue, int *ival)
{
int v;
if(IsIntNumber(val))
	{
	v=atoi(val);
	if(isInRange(v,minValue,maxValue,'B'))
		{
		*ival=v;
		return true;
		}
	}
dbg->trace(DBG_ERROR,"number out of range");
return false;
}


/**
 * create a log file
 * @param log
 * @return
 */
bool GuiMainWindow::logToFile(const char* log)
{
if(enableLog)
	{
	return saveLogFile(logFilename,log);
	}
return true;
}

/**
 * set the status bar
 * @param type 'N' notify; 'W' warning; 'E' error; 'C' clear
 * @param msg (ignored for 'C')
 */
void GuiMainWindow::setStatusBarInfo(char type, const char *msg)
{
switch(type)
	{
	case 'C':	// clear
		status_box->labelcolor(FL_BLACK);
		status_box->color((Fl_Color)FL_LIGHT2);
		status_box->copy_label("----");
		break;
	case 'N':
		status_box->labelcolor(FL_BLACK);
		status_box->copy_label(msg);
		break;
	case 'W':
		status_box->labelcolor(FL_DARK_YELLOW);
		status_box->copy_label(msg);
		break;
	case 'E':
		status_box->labelcolor(FL_RED);
		status_box->copy_label(msg);
		break;
	}

// force redraw immediately
Fl::check();
}
//-----------------------------------------------------------------------------
// CALLBACKS
//-----------------------------------------------------------------------------
/**
 * connection event
 */
void GuiMainWindow::onConnect_CB(Fl_Button* w, void* data)
{
int val;
checkDeviceType(commDevice_in->value());

// get device name
strcpy(gd.device,commDevice_in->value());	//serial port or IP
tf->setCommInterface();

win->label(GUI_TITLE);

switch(gd.interface)
	{
	//..............................
	case globals_st::if_fifo:
		send_but->deactivate();
		cklnk_but->deactivate();
		result_box->deactivate();
		myId_in->deactivate();
		destId_in->deactivate();
		cmds_cb->deactivate();
		gd.brate=0;
		gd.port=0;
		this->setStatusBarInfo('N',"waiting connection...");
		if(!gd.connected)
			{
			if(fifoComm->openCommunication(gd.device,0))
				{
				this->setStatusBarInfo('C',NULL);
				dbg->trace(DBG_NOTIFY,"fifo " + _S gd.device + " opened (read only)");
				fifoComm->startThread(NULL,'r');	// start the listener thread
				connect_but->color(FL_GREEN);
				connect_but->label("connected");
				gd.connected=true;
				dbg->trace(DBG_NOTIFY,"connected");
				rf->setPrintEnable(true);
				win->label(GUI_TITLE " - Fifo");
				}
			else
				{
				dbg->trace(DBG_ERROR,"creating/opening fifo " + _S gd.device);
				fl_alert("Cannot open fifo");
				}
			}
		else
			{
			fifoComm->closeCommunication();
			fifoComm->joinThread('r');
			connect_but->color(FL_GRAY);
			connect_but->label("connect");
			gd.connected=false;
			dbg->trace(DBG_NOTIFY,"disconnected");
			rf->setPrintEnable(false);
			}

		break;
		//..............................
	case globals_st::if_serial:
		send_but->activate();
		cklnk_but->activate();
		result_box->activate();
		myId_in->activate();
		destId_in->activate();
		cmds_cb->activate();
		gd.brate=atoi(commBR_in->value());	// baud rate or port
		if(!gd.connected)
			{
			dbg->trace(DBG_NOTIFY, _S "opening serial port: " + _S gd.device + " baud: " + to_string(gd.brate));
			if(!serComm->openCommunication(gd.device, gd.brate))
				{
				dbg->trace(DBG_ERROR,"cannot open serial port");
				fl_alert("Cannot open serial port");
				return;
				}
			if(getFldNumber(myId_in->value(),0,250,&val))
				{
				serComm->setMyId(val);
				}
			else
				{
				fl_alert("src ID out of range (0-250)");
				return;
				}
			serComm->startThread(NULL,'r');	// start the listener thread
			connect_but->color(FL_GREEN);
			connect_but->label("connected");
			gd.connected=true;
			dbg->trace(DBG_NOTIFY,"connected");
			rf->setPrintEnable(true);
			win->label(GUI_TITLE " - Serial");
			}
		else
			{
			serComm->closeCommunication();
			serComm->joinThread('r');
			connect_but->color(FL_GRAY);
			connect_but->label("connect");
			gd.connected=false;
			dbg->trace(DBG_NOTIFY,"disconnected");
			rf->setPrintEnable(false);
			}
		break;
	//..............................
	case globals_st::if_socket_cli:
		send_but->activate();
		cklnk_but->activate();
		result_box->activate();
		myId_in->activate();
		destId_in->activate();
		cmds_cb->activate();
		gd.port=atoi(commBR_in->value());	// baud rate or port
		if(!gd.connected)
			{
			dbg->trace(DBG_NOTIFY, _S "opening IP socket: " + _S gd.device + " port: " + to_string(gd.port));
			if(!sktCliComm->openCommunication(gd.device, gd.port))
				{
				dbg->trace(DBG_ERROR,"cannot open IP socket");
				fl_alert("Cannot open socket");
				return;
				}
			if(getFldNumber(myId_in->value(),0,250,&val))
				{
				sktCliComm->setMyId(val);
				}
			else
				{
				fl_alert("src ID out of range (0-250)");
				return;
				}
			sktCliComm->setPacketProtocol(true);
			sktCliComm->startThread(NULL,'r');	// start the listener thread
			connect_but->color(FL_GREEN);
			connect_but->label("connected");
			gd.connected=true;
			dbg->trace(DBG_NOTIFY,"connected");
			rf->setPrintEnable(true);
			win->label(GUI_TITLE " - Client");
			}
		else
			{
			sktCliComm->closeCommunication();
			sktCliComm->joinThread('r');
			connect_but->color(FL_GRAY);
			connect_but->label("connect");
			gd.connected=false;
			dbg->trace(DBG_NOTIFY,"disconnected");
			rf->setPrintEnable(false);
			}
		break;
	//..............................
	case globals_st::if_socket_srv:
		send_but->activate();
		cklnk_but->activate();
		result_box->activate();
		myId_in->activate();
		destId_in->activate();
		cmds_cb->activate();
		gd.port=atoi(commBR_in->value());	// baud rate or port
		if(!gd.connected)
			{
			dbg->trace(DBG_NOTIFY, _S "starting server at port " + to_string(gd.port));
			if(!sktSrvComm->openCommunication(gd.device, gd.port))
				{
				dbg->trace(DBG_ERROR,"cannot create server");
				fl_alert("Cannot create server");
				return;
				}
			if(getFldNumber(myId_in->value(),0,250,&val))
				{
				sktSrvComm->setMyId(val);
				}
			else
				{
				fl_alert("src ID out of range (0-250)");
				return;
				}
			sktSrvComm->setPacketProtocol(true);
			sktSrvComm->startThread(NULL,'r');	// start the listener thread
			connect_but->color(FL_GREEN);
			connect_but->label("connected");
			gd.connected=true;
			dbg->trace(DBG_NOTIFY,"connected");
			sktSrvComm->loadAnswerFile(SRV_ANSWER_FILE);
			rf->setPrintEnable(true);
			win->label(GUI_TITLE " - Server");
			}
		else
			{
			sktSrvComm->closeCommunication();
			sktSrvComm->joinThread('r');
			connect_but->color(FL_GRAY);
			connect_but->label("connect");
			gd.connected=false;
			dbg->trace(DBG_NOTIFY,"disconnected");
			rf->setPrintEnable(false);
			}
		break;
	//..............................
	case globals_st::if_socket_udp:
		send_but->activate();
		cklnk_but->activate();
		result_box->activate();
		myId_in->activate();
		destId_in->activate();
		cmds_cb->activate();
		gd.port=atoi(commBR_in->value());	// baud rate or port
		if(!gd.connected)
			{
			dbg->trace(DBG_NOTIFY, _S "starting UDP server at port " + to_string(gd.port));
			if(!udpSrvComm->openCommunication(gd.device, gd.port))
				{
				dbg->trace(DBG_ERROR,"cannot create server");
				fl_alert("Cannot create server");
				return;
				}
			if(getFldNumber(myId_in->value(),0,250,&val))
				{
				udpSrvComm->setMyId(val);
				}
			else
				{
				fl_alert("src ID out of range (0-250)");
				return;
				}
			udpSrvComm->setPacketProtocol(true);
			udpSrvComm->startThread(NULL,'r');	// start the listener thread
			connect_but->color(FL_GREEN);
			connect_but->label("connected");
			gd.connected=true;
			dbg->trace(DBG_NOTIFY,"connected");
			udpSrvComm->loadUdpIpFile(SRV_UDP_IDIP_MAP_FILE);
			rf->setPrintEnable(true);
			win->label(GUI_TITLE " - Server");
			}
		else
			{
			udpSrvComm->closeCommunication();
			udpSrvComm->joinThread('r');
			connect_but->color(FL_GRAY);
			connect_but->label("connect");
			gd.connected=false;
			dbg->trace(DBG_NOTIFY,"disconnected");
			rf->setPrintEnable(false);
			}
		break;
	}

onCryptoKeySet_CB(setCryptoKey_but,NULL);
onEnableCrypto_CB(enCrypto_ck,NULL);

if(gd.enableCrypto)
	{
	char tmp[100];
	sprintf(tmp,"%s (crypto)",win->label());
	win->label(tmp);
	}
}

/**
 * set the new crypto key
 */
void GuiMainWindow::onCryptoKeySet_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
if(strcmp(cryptoKey_in->value(),"default")==0)
	{
	gd.hprotKey[0]=HPROT_CRYPT_DEFAULT_KEY0;
	gd.hprotKey[1]=HPROT_CRYPT_DEFAULT_KEY1;
	gd.hprotKey[2]=HPROT_CRYPT_DEFAULT_KEY2;
	gd.hprotKey[3]=HPROT_CRYPT_DEFAULT_KEY3;
	}
else
	{
	char _tmpstr[20];
	strncpy(_tmpstr,cryptoKey_in->value(),HPROT_CRYPT_KEY_SIZE*2);
	_tmpstr[HPROT_CRYPT_KEY_SIZE*2]=0;		// ensure termination
	for(int i=0;i<HPROT_CRYPT_KEY_SIZE*2;i++)
		{
		if(!isxdigit(_tmpstr[i]))
			{
			fl_alert("Invalid crypto key, must be 8 char and in the hex char set or 'default'");
			cryptoKey_in->value("default");
			return;
			}
		}
	AsciiHex2Hex(gd.hprotKey,(char *)cryptoKey_in->value(),HPROT_CRYPT_KEY_SIZE);
	}

switch(gd.interface)
	{
	case globals_st::if_serial:
		serComm->setNewKey(gd.hprotKey);
		break;
	case globals_st::if_socket_cli:
		sktCliComm->setNewKey(gd.hprotKey);
		break;
	case globals_st::if_socket_srv:
		sktSrvComm->setNewKey(gd.hprotKey);
		break;
	case globals_st::if_socket_udp:
		udpSrvComm->setNewKey(gd.hprotKey);
		break;
	case globals_st::if_fifo:
		fifoComm->setNewKey(gd.hprotKey);
		break;
	}
cfg->updateVariable("CRYPTO_KEY",cryptoKey_in->value());
cfg->saveCfgFile();
}

/**
 * enable/disable crypto
 */
void GuiMainWindow::onEnableCrypto_CB(Fl_Check_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
bool en=false;
en= (w->value()==1) ? (true) : (false);

switch(gd.interface)
	{
	case globals_st::if_serial:
		serComm->enableCrypto(en);
		break;
	case globals_st::if_socket_cli:
		sktCliComm->enableCrypto(en);
		break;
	case globals_st::if_socket_srv:
		sktSrvComm->enableCrypto(en);
		break;
	case globals_st::if_socket_udp:
		udpSrvComm->enableCrypto(en);
		break;
	case globals_st::if_fifo:
		sktCliComm->enableCrypto(en);
		break;
	}
cfg->updateVariable("ENABLE_CRYPTO",(en) ? ("Y") : ("N"));
cfg->saveCfgFile();

// clear all
log_tbuff->text("");
log_sbuff->text("");
percClear->copy_label("0%");
percClear->color((Fl_Color)FL_GREEN);
rf->clearQueue();
}


/**
 * browse file
 * @param w
 * @param data
 */
void GuiMainWindow::onFile_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
// Create the file chooser, and show it
Fl_File_Chooser chooser(".",  // directory
"*.raw\t*",                        	// filter
Fl_File_Chooser::SINGLE,     	// chooser type SINGLE or MULTI
"Binary protocol stream");        	// title
chooser.preview(0);	// disable preview
chooser.show();

// Block until user picks something.
//     (The other way to do this is to use a callback())
//
while(chooser.shown())
	{
	Fl::wait();
	}

// User hit cancel?
if(chooser.value() == NULL)
	{
	fprintf(stderr, "(User hit 'Cancel')\n");
	return;
	}
// Print what the user picked
//fprintf(stderr, "--------------------\n");
//fprintf(stderr, "DIRECTORY: '%s'\n", chooser.directory());
//fprintf(stderr, "    VALUE: '%s'\n", chooser.value());
//fprintf(stderr, "    COUNT: %d files selected\n", chooser.count());
dbg->trace(DBG_NOTIFY,"selected file: %s", chooser.value());

// parse and print file contents
ifstream ifile(chooser.value(),ios::in | ios::binary);
char _buf[10];
uint8_t fdata[HPROT_BUFFER_SIZE];
frame_t f;
protocolData_t _pd;
int nframes=0;

if(!rf->getPrintEnable())
	{
	rf->setPrintParam(true,true,true,true,gd.dumpTrigger);
	rf->setPrintEnable(true);
	}
hprotInit(&_pd,NULL,NULL,NULL,NULL);
#ifdef HPROT_USE_CRYPTO
hprotSetKey(&_pd,gd.hprotKey);
#endif
hprotFrameSetup(&f,fdata);

while(!ifile.eof())
	{
	ifile.read(_buf, 1);
	hprotFrameParserNData(&_pd,&f,(uint8_t*)_buf,1);
	if(_pd.protCondition==pc_ok || _pd.protCondition==pc_error_crc || _pd.protCondition==pc_error_cmd)
		{
		rf->printFrame('-',_pd.rxRawBuffer,_pd.rxRawBufferCount,_pd.protCondition);
		_pd.rxRawBufferCount=0;
		nframes++;
		hprotReset(&_pd);
		}
	}
dbg->trace(DBG_NOTIFY,"Parsed %d valid frames",nframes);
ifile.close();
}


/**
 * reload some configuration values
 */
void GuiMainWindow::onReload_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
dbg->trace(DBG_NOTIFY,"Reloading mapping files");
rf->loadDbgMessageMap(DBGMSG_MAP_FILE);
rf->loadDbgVariableMap(SBGMSG_VAR_FILE);
rf->loadDbgCommandMap(CMDMSG_MAP_FILE);
if(gd.interface==globals_st::if_socket_udp)
	{
	udpSrvComm->loadUdpIpFile(SRV_UDP_IDIP_MAP_FILE);
	}
}

/**
 * reload some configuration values
 */
void GuiMainWindow::onListDevices_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
string msg="";
char tmp[100];
//dbg->trace(DBG_NOTIFY,"Devices listing");
sprintf(tmp,"Total devices: %d",(int)gd.devices.size());
msg += _S tmp + "\n\n";
for(unsigned int i=0;i<gd.devices.size();i++)
	{
	sprintf(tmp,"id %-3d (nframes=%d; errors=%d; chklnks=%d)",gd.devices[i].id,gd.devices[i].nframes,gd.devices[i].errors,gd.devices[i].chklnks);
	msg += _S tmp;
	switch(gd.devices[i].id)
		{
		case HPROT_INVALID_ID:
			msg += " invalid id";
			break;
		case HPROT_BROADCAST_ID:
			msg += " broadcast";
			break;
		case HPROT_DEBUG_ID:
			msg += " debug";
			break;
		}
	msg += "\n";
	}

fl_message(msg.c_str());

//-------------------------------------------------------------
msg.clear();
// append commands statistics
msg += "\nCommands statistics:\n-----------------------------\n";
for(unsigned int c=0;c<256;c++)
	{
	if(gd.commandStats.find(c)!=gd.commandStats.end()) // if exists...
		{
		if(gd.commandStats[c].name[0]==0)	// if it has a mapped name
			{
			sprintf(tmp,"cmd %-3d : %d\n",c,gd.commandStats[c].n);
			}
		else
			{
			sprintf(tmp,"cmd %-3d (%s): %d\n",c,gd.commandStats[c].name,gd.commandStats[c].n);
			}
		msg += _S tmp;
		}
	}

fl_message(msg.c_str());

//-------------------------------------------------------------
msg.clear();
// append frame velocity
msg += _S "\nFrame rates:\n-----------------------------\n" +
											"last " + strFormat("%0.1f",rf->getFrameRate()) + " frame/s\n" +
											"min " + strFormat("%0.1f",rf->getFrameRateMin()) + " frame/s\n" +
											"max " + strFormat("%0.1f",rf->getFrameRateMax()) + " frame/s";

fl_message(msg.c_str());
}

/**
 * reload some configuration values
 */
void GuiMainWindow::onFrameAnalizer_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
const char *inframe;
char *frame;
uint8_t dat[HPROT_BUFFER_SIZE*2];

inframe=fl_input("Insert the frame (hex format space separated");
if(inframe==NULL)
	{
	return;
	}

frame=strdup(inframe);
// removes all spaces
char* i = frame;
char* j = frame;
while(*j != 0)
	{
	*i = *j++;
	if(*i != ' ') i++;
	}
*i = 0;

if(strlen(frame)>=(HPROT_OVERHEAD_SIZE*2))
	{
	protocolData_t pd;
	uint8_t frameData[HPROT_BUFFER_SIZE];
	frame_t f;
	string dumpdata;
	char hdr;
	char msg[100];

	hprotInit(&pd,NULL,NULL,NULL,NULL);
	hprotReset(&pd);
	hprotFrameSetup(&f,frameData);
	if(enCrypto_ck->value()==1)
		{
		hprotSetKey(&pd,gd.hprotKey);
		hprotEnableCrypto(&pd);
		}
	else
		{
		hprotDisableCrypto(&pd);
		}

	int n=AsciiHex2Hex(dat,frame,strlen(frame));

	n=hprotFrameParserNData(&pd,&f,dat,n);
	switch(pd.protCondition)
		{
		case pc_idle:
			fl_alert("Frame ERROR:  unknown format (header missing?)");
			break;
		case pc_ok:
			hexdumpStr(dumpdata,f.data,f.len);
			dumpdata.erase(std::remove(dumpdata.begin(), dumpdata.end(), '\r'), dumpdata.end());
			switch(f.hdr)
				{
				case HPROT_HDR_ANSWER:
					hdr='A';
					break;
				case HPROT_HDR_COMMAND:
					hdr='C';
					break;
				case HPROT_HDR_REQUEST:
					hdr='R';
					break;
				}
			fl_message("Frame OK:\n\nhdr:%c\nsrc:%d (%02Xh)\ndst:%d (%02Xh)\nnum:%d (%02Xh)\ncmd:%d (%02Xh)\nlen:%d (%02Xh)\ncrc:%02Xh\ndata (dump):\n%s\ndata excess:%d",
					hdr,
					f.srcID,
					f.srcID,
					f.dstID,
					f.dstID,
					f.num,
					f.num,
					f.cmd,
					f.cmd,
					f.len,
					f.len,
					f.crc,
					dumpdata.c_str(),
					n
					);
			break;
		case pc_inprogress:
			switch(f.hdr)
				{
				case HPROT_HDR_ANSWER:
					hdr='A';
					break;
				case HPROT_HDR_COMMAND:
					hdr='C';
					break;
				case HPROT_HDR_REQUEST:
					hdr='R';
					break;
				}
			switch(pd.rxInternalStatus)
				{
				case ipsm_IDLE:
					strcpy(msg,"idle");
					break;
				case ipsm_HEADER:
					strcpy(msg,"hdr");
					break;
				case ipsm_NUM:
					strcpy(msg,"num");
					break;
				case ipsm_CMD:
					strcpy(msg,"cmd");
					break;
				case ipsm_LEN:
					strcpy(msg,"len");
					break;
				case ipsm_SRCID:
					strcpy(msg,"src_id");
					break;
				case ipsm_DSTID:
					strcpy(msg,"dst_id");
					break;
				case ipsm_DATA:
					strcpy(msg,"data");
					break;
				case ipsm_CKCRC:
					strcpy(msg,"crc");
					break;
				}
			fl_alert("ERROR: Incomplete PARSE (%s):\n\nhdr:%c\nsrc:%d (%02Xh)\ndst:%d (%02Xh)\nnum:%d (%02Xh)\ncmd:%d (%02Xh)\nlen:%d (%02Xh)\ncrc:%02Xh",
					msg,
					hdr,
					f.srcID,
					f.srcID,
					f.dstID,
					f.dstID,
					f.num,
					f.num,
					f.cmd,
					f.cmd,
					f.len,
					f.len,
					f.crc
					);

			break;
		case pc_error_crc:
			fl_message("crc error");
			break;
		case pc_error_cmd:
			fl_message("cmd error");
			break;
		}
	}
free((void*)frame);
}

/**
 * send a frame
 */
void GuiMainWindow::onSend_CB(Fl_Button* w, void* data)
{
//printLog("attenzione, $Cquesta $Eè una prova$-\n");
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
if(!gd.connected)
	{
	fl_message("cannot send, device disconnected?");
	return;
	}

string cmd(cmds_cb->value());
dbg->trace(DBG_DEBUG,"parsing frame: " + cmd);
bool ret=tf->parseDescFrame(cmd);
if(ret)
	{
	result_box->copy_label("----");
	if(find(commandList.begin(), commandList.end(), cmd) == commandList.end())
		{
	  // someName not in name, add it
		commandList.push_back(cmd);
		cmds_cb->add(cmd.c_str());
		}
	tf->transmitFrame();

	// save the command file
	saveStrVec2File(gd.cmd_fname,commandList);
	}
else
	{
	fl_alert(tf->getErrorMessage().c_str());
	}
}

/**
 * clear log window
 */
void GuiMainWindow::onClear_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
log_tbuff->text("");
log_sbuff->text("");
percClear->copy_label("0%");
percClear->color((Fl_Color)FL_GREEN);
rf->clearQueue();
}

/**
 * clear log window
 */
void GuiMainWindow::onMark_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
char tmp[50];
(markerNumber<99) ? (markerNumber++) : (markerNumber=0);
sprintf(tmp,"***[MARKER_%02d]***\n",markerNumber);
rf->logToFile((uint8_t*)tmp,0,true);
printLog(tmp);
}

/**
 *  pause log
 */
void GuiMainWindow::onPause_CB(Fl_Light_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
if(pause_but->value()==1)
	{
	// pause state
	dbg->trace(DBG_NOTIFY,"tracing paused");
	printLog("--PAUSED--\n");
	rf->setPrintEnable(false);
	}
else
	{
	dbg->trace(DBG_NOTIFY,"tracing resumed");
	printLog("--RESUMED--\n");
	rf->resetFrameRate();
	rf->setPrintEnable(true);
	rf->clearQueue();
	}
}

/**
 *  check link
 */
void GuiMainWindow::onCkLnk_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
string cmd("r.s.d.3");
result_box->copy_label("----");
tf->parseDescFrame(cmd);
tf->transmitFrame();
}

/**
 * clear log window
 */
void GuiMainWindow::onVarClear_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
varDB.clear();
varBrowser_br->clear();
}


/**
 * clear log window
 */
void GuiMainWindow::onVarPlot_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;

scope=new ScopeViewWindow();
scope->render();
scope->setTick(0.01);
scope->setYrange(-2.0,4.0);
scope->setGrid(5,6);
scope->start();

//float buff[100];
//for(int i=0;i<100;i++)
//	{
//	buff[i]=(float)i/100;
//	}
//scope->setData(buff,100);
}

/**
 * clear log window
 */
void GuiMainWindow::onFilterSet_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
string fil(filter_cb->value());
dbg->trace(DBG_DEBUG,"parsing filter: " + fil);
bool ret=rf->ffil.parseFilter(fil);
if(ret)
	{
	if(find(filterList.begin(), filterList.end(), fil) == filterList.end())
		{
	  // someName not in name, add it
		filterList.push_back(fil);

//		// search for special chars
//		string sfil;
//		for(unsigned int i=0;i<fil.length();i++)
//			{
//		  switch(fil[i])
//				{
//		  	case '&':
//		  		sfil.append("\&");
//		  		break;
//		  	case '|':
//		  		sfil.append("\|");
//		  		break;
//		  	default:
//		  		sfil += fil[i];
//		  		break;
//				}
//			}

	  filter_cb->add(fil.c_str());

		// save the filter file
		saveStrVec2File(gd.fil_fname,filterList);
		}
	}
else
	{
	fl_alert("invalid filter format");
	}
}

/**
 * enable/disable filter
 */
void GuiMainWindow::onEnableFilter_CB(Fl_Check_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
(enFilter_ck->value()==1) ? (rf->setfilterEnable(true)) : (rf->setfilterEnable(false));
if(enFilter_ck->value()==1)
	{
	dbg->trace(DBG_NOTIFY,"enable filter");
	}
else
	{
	dbg->trace(DBG_NOTIFY,"disable filter");
	}
}

/**
 * enable/disable filter for only debug messages
 * @param w
 * @param data
 */
void GuiMainWindow::onEnableDbgFilter_CB(Fl_Check_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
(enDbgFilter_ck->value()==1) ? (rf->setShowDbgOnly(true)) : (rf->setShowDbgOnly(false));
if(enDbgFilter_ck->value()==1)
	{
	dbg->trace(DBG_NOTIFY,"enable debug filter");
	}
else
	{
	dbg->trace(DBG_NOTIFY,"disable debug filter");
	}
}

/**
 * enable/disable filter for only debug messages
 * @param w
 * @param data
 */
void GuiMainWindow::onEnableMappedCommands_CB(Fl_Check_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
(enMapCommands_ck->value()==1) ? (rf->setShowMappedCmds(true)) : (rf->setShowMappedCmds(false));
if(enMapCommands_ck->value()==1)
	{
	dbg->trace(DBG_NOTIFY,"enable mapped commands");
	}
else
	{
	dbg->trace(DBG_NOTIFY,"disable mapped commands");
	}
}

/**
 * enable log binary as from the serial port
 * @param w
 * @param data
 */
void GuiMainWindow::onLogRawBin_CB(Fl_Check_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
if(logRawBin_ck->value()==1)
	{
	switch(gd.interface)
		{
		//..............................
		case globals_st::if_serial:
			serComm->setEnableLog(true);
			(gd.logBinaryFormat=='T') ? (serComm->setLogModeBinary(false)) : (serComm->setLogModeBinary(true));
			serComm->setLogFilename(gd.logRawBin_fname);
			break;
		//..............................
		case globals_st::if_fifo:
			fifoComm->setEnableLog(true);
			(gd.logBinaryFormat=='T') ? (fifoComm->setLogModeBinary(false)) : (fifoComm->setLogModeBinary(true));
			fifoComm->setLogFilename(gd.logRawBin_fname);
			break;
		//..............................
		case globals_st::if_socket_cli:
			sktCliComm->setEnableLog(true);
			(gd.logBinaryFormat=='T') ? (sktCliComm->setLogModeBinary(false)) : (sktCliComm->setLogModeBinary(true));
			sktCliComm->setLogFilename(gd.logRawBin_fname);
			break;
		//..............................
		case globals_st::if_socket_srv:
			sktSrvComm->setEnableLog(true);
			(gd.logBinaryFormat=='T') ? (sktSrvComm->setLogModeBinary(false)) : (sktSrvComm->setLogModeBinary(true));
			sktSrvComm->setLogFilename(gd.logRawBin_fname);
			break;
		//..............................
		case globals_st::if_socket_udp:
			udpSrvComm->setEnableLog(true);
			(gd.logBinaryFormat=='T') ? (udpSrvComm->setLogModeBinary(false)) : (udpSrvComm->setLogModeBinary(true));
			udpSrvComm->setLogFilename(gd.logRawBin_fname);
			break;
		}
	dbg->trace(DBG_NOTIFY,"enable lower level raw log");
	}
else
	{
	switch(gd.interface)
		{
		//..............................
		case globals_st::if_serial:
			serComm->setEnableLog(false);
			break;
		//..............................
		case globals_st::if_fifo:
			fifoComm->setEnableLog(false);
			break;
		//..............................
		case globals_st::if_socket_cli:
			sktCliComm->setEnableLog(false);
			break;
		//..............................
		case globals_st::if_socket_srv:
			sktSrvComm->setEnableLog(false);
			break;
		//..............................
		case globals_st::if_socket_udp:
			udpSrvComm->setEnableLog(false);
			break;
		}
	dbg->trace(DBG_NOTIFY,"disable lower level raw log");
	}
}

/**
 * log text version (only valid frames)
 * @param w
 * @param data
 */
void GuiMainWindow::onLogRawTxt_CB(Fl_Check_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
if(logRawTxt_ck->value()==1)
	{
	rf->setEnableLog(true);
	dbg->trace(DBG_NOTIFY,"enable raw log");
	}
else
	{
	rf->setEnableLog(false);
	dbg->trace(DBG_NOTIFY,"disable raw log");
	}
}

/**
 * log parsed
 * @param w
 * @param data
 */
void GuiMainWindow::onLogParsTxt_CB(Fl_Check_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
if(logParsTxt_ck->value()==1)
	{
	setEnableLog(true);
	dbg->trace(DBG_NOTIFY,"enable parsed log");
	}
else
	{
	setEnableLog(false);
	dbg->trace(DBG_NOTIFY,"disable parsed log");
	}
}

/**
 * timer enable/disable
 * @param w
 * @param data
 */
void GuiMainWindow::onTimerEnable_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
//timerStartFilter
if(timerEnable->value()==1)
	{
	rf->timerMeasure.initTime_ms();
	rf->timerFilterStartEnable=false;
	rf->timerFilterStopEnable=false;
	if(strlen(timerStart->value())>0)
		{
		if(!rf->timerStartFilter.parseFilter(timerStart->value()))
			{
			fl_alert("bad start timer filter");
			return;
			}
		rf->timerFilterStartEnable=true;
		}
	if(strlen(timerStop->value())>0)
		{
		if(!rf->timerStopFilter.parseFilter(timerStop->value()))
			{
			fl_alert("bad stop timer filter");
			return;
			}
		rf->timerFilterStopEnable=true;
		}
	rf->timerEnabled=true;
	rf->timerStarted=true;
	}
else
	{
	rf->timerEnabled=false;
	rf->timerFilterStartEnable=false;
	rf->timerFilterStopEnable=false;
	rf->timerStarted=false;
	}
}

/**
 * delete all log files
 */
void GuiMainWindow::onDeleteLogFiles_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
dbg->trace(DBG_WARNING,"removing log file " + gd.logParsTxt_fname);
remove(gd.logParsTxt_fname.c_str());
dbg->trace(DBG_WARNING,"removing log file " + gd.logRawBin_fname);
remove(gd.logRawBin_fname.c_str());
dbg->trace(DBG_WARNING,"removing log file " + gd.logRawTxt_fname);
remove(gd.logRawTxt_fname.c_str());
}

/**
 * delete all log files
 */
void GuiMainWindow::onClearCounters_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented"<< endl;
dbg->trace(DBG_NOTIFY,"clear all counters");
gd.rxFrameCounter=0;
gd.txFrameCounter=0;
rf->clearCounters();
setStatusBarInfo('C',NULL);
}

/**
 * clear log window
 */
void GuiMainWindow::onSpareButton_CB(Fl_Button* w, void* data)
{
//cout << __FUNCTION__<< ": not yet implemented "<< w->label() << endl;
dbg->trace(DBG_NOTIFY,"spare button %s pressed",w->label());
for(int i=0;i<SPARE_BUTTONS_N;i++)
	{
	if(strcmp(w->label(),(to_string(i+1) + "_" + gd.spareButton[i].name).c_str())==0)
		{
		if(gd.spareButton[i].enable)
			{
			if(startsWith(gd.spareButton[i].exe,"script"))
				{
				// exe script
				int sn=atoi(&gd.spareButton[i].exe[strlen("script")]);
				if(sn>0 && sn<WP_MAX_SCRIPTS)
					{
					wp->execute(sn-1,NULL,0,true);
					}
				else
					{
					dbg->trace(DBG_ERROR,"script number out of range (script%d)",sn);
					}
				}
			else if(gd.spareButton[i].exe=="none")
				{
				dbg->trace(DBG_NOTIFY,"nothing to to");
				// do nothing
				}
			else if(strpbrk(gd.spareButton[i].exe.c_str(),"cra")!=NULL)
				{
				// send frame
				if(tf->parseDescFrame(gd.spareButton[i].exe))
					{
					tf->transmitFrame();
					}
				}
			}
		}
	}
}

//............................................................

/**
 * refresh what I need to refresh during idle state
 */
void GuiMainWindow::onRefreshGui_CB(void *data)
{
if(needRefresh)
	{
	win->redraw();
	needRefresh=false;
	}
usleep(10000); // to release the CPU to 100%
}


#define MSG_QUEUE_HANDLED		50
/**
 * handle the print queue
 * @param data
 */
void GuiMainWindow::onTimerPrintQueue_CB(void *data)
{
RXHFrame::qdata_t q;
int n=0;
char _str[30];

// update frame counters
sprintf(_str,"%llu",gd.rxFrameCounter);
rxFrameCount_box->copy_label(_str);
sprintf(_str,"%llu",gd.txFrameCounter);
txFrameCount_box->copy_label(_str);

if(rf->depthQueue() >= ABSOLUTE_MAX_QUEUE_GUARD)
	{
	printLog("%%s*** WARN : OUT OF QUEUE ***");
	dbg->trace(DBG_ERROR,"out of queue: messages lost");
	setStatusBarInfo('E',"ERROR: out of queue");
	rf->clearQueue();
	}
//else
//	{
//	//dbg->trace(DBG_WARNING,"queue depth: " + rf->depthQueue());
//	dbg->trace(DBG_WARNING,"near to out of queue: communication too fast");
//	setStatusBarInfo('W',"WARN: near to out of queue -> clearing (messages are lost)");
//	rf->clearQueue();
//	}

while(!rf->isEmptyQueue() && n< MSG_QUEUE_HANDLED)
	{
	rf->getQueue(&q);
	rf->printFrame(q.dir,q.data,q.size,q.fr_error);
	n++;
	usleep(1000);	// to release some resources
	}

// handle TX->RX
if(tf->isError())
	{
	dbg->trace(DBG_DEBUG,"TX error: "+ tf->getErrorMessage());
	result_box->copy_label("Error");
	tf->resetResult();
	}
else if(tf->isWaiting())
	{
	result_box->copy_label("Waiting");
	tf->resetResult();
	}
else if(tf->isOk())
	{
	result_box->copy_label("OK");
	tf->resetResult();
	}

// handle timer
if(rf->timerStarted)
	{
	div_t qr;
	unsigned int totmsec=rf->timerMeasure.getElapsedTime_ms();
  qr = div(totmsec, 1000);
  int ms = qr.rem;
  qr = div(qr.quot, 60);
  int sec  = qr.rem;
  qr = div(qr.quot, 60);
  int min  = qr.rem;
  int hr  = qr.quot;

	char ts[20];
	sprintf(ts,"%02d:%02d:%02d %03d",hr,min,sec,ms);
	timerWatch->copy_label(ts);
	}

//if(serComm->getResultStatus()==Result::is_error)
//	{
//	dbg->trace(DBG_DEBUG,"Protocol error: "+ serComm->getErrorMessage());
//	}

Fl::repeat_timeout(GUI_CHECK_FRAME_QUEUE, STATIC_SIMPLE_CALLBACK_NAME(onTimerPrintQueue_CB),this);
}


